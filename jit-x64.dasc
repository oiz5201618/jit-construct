#include <stdint.h>
#include "util.h"

|.arch x64
|.actionlist actions
|
|// Use rbx as our cell pointer.
|// Since rbx is a callee-save register, it will be preserved
|// across our calls to getchar and putchar.
|.define PTR, rbx
|
|// Macro for calling a function.
|// In cases where our target is <=2**32 away we can use
|//   | call &addr
|// But since we don't know if it will be, we use this safe
|// sequence instead.
|.macro callp, addr
|  mov64  rax, (uintptr_t)addr
|  call   rax
|.endmacro

#define Dst &state
#define MAX_NESTING 256

int continuous_count(char *p);
int check_loops(char *p,int *index,int *mult);
int global_count;

int main(int argc, char *argv[])
{
    if (argc < 2) err("Usage: jit-x64 <inputfile>");
    dasm_State *state;
    initjit(&state, actions);

    unsigned int maxpc = 0;
    int pcstack[MAX_NESTING];
    int *top = pcstack, *limit = pcstack + MAX_NESTING;
    int count = 0;
    int index[1000];
    int mult[1000];

    // Function prologue.
    |  push PTR
    |  mov  PTR, rdi      // rdi store 1st argument

    for (char *p = read_file(argv[1]); *p; p++) {
	switch (*p) {
            case '>':
                count = continuous_count(p);
                p += count - 1;
                |  add  PTR, count
                break;
            case '<':
                count = continuous_count(p);
                p += count - 1;
                |  sub  PTR, count
                break;
            case '+':
                count = continuous_count(p);
                p += count - 1;
                |  add  byte [PTR], count
                break;
            case '-':
                count = continuous_count(p);
                p += count - 1;
                |  sub  byte [PTR], count
                break;
            case '.':
                |  movzx edi, byte [PTR]
                |  callp putchar
                break;
            case ',':
                |  callp getchar
                |  mov   byte [PTR], al
                break;
            case '[':
                if (top == limit) err("Nesting too deep.");
                // Each loop gets two pclabels: at the beginning and end.
                // We store pclabel offsets in a stack to link the loop
                // begin and end together.

                count = check_loops(p, index, mult);

                if(count == 0){
                    p += global_count;
                    |  mov  byte [PTR], 0
                    break;

                }else if(count > 0){
                    |  mov  cx, word [PTR]
                    |  mov  r11, PTR
                    |  add  PTR, index[0]
                    |  mov  ax, word mult[0]
                    |  imul  ax, cx
                    |  add  byte [PTR], al

                    for(int i = 1; i < count; i++){
                        |  mov  r9, index[i]
                        |  sub  r9, index[i - 1]
                        |  add  PTR, r9
                        |  mov  ax, mult[i]
                        |  imul  ax, cx
                        |  add  byte [PTR], al
                    }

                    |  mov  PTR, r11
                    |  mov  byte [PTR], 0
     
                    p += global_count;
                    break;

                }else{
                    maxpc += 2;
                    *top++ = maxpc;
                    dasm_growpc(&state, maxpc);
                    |  cmp  byte [PTR], 0
                    |  je   =>(maxpc-2)
                    |=>(maxpc-1):
                    break;
                }
                
            case ']':
                if (top == pcstack) err("Unmatched ']'");
                top--;
                |  cmp  byte [PTR], 0
                |  jne  =>(*top-1)
                |=>(*top-2):
                break;
            }
        }

    // Function epilogue.
    |  pop  PTR
    |  ret

    void (*fptr)(char*) = jitcode(&state);
    char *mem = calloc(30000, 1);
    fptr(mem);
    free(mem);
    free_jitcode(fptr);
    return 0;
}

int continuous_count(char *p)
{
    char *ptr = p;
    int count = 0;
    while (*ptr == *p) {
        count++;
        ptr++;
    }
    return count;
}

int check_loops(char *p,int *index,int *mult)
{
    int res,offset = 0,_index = 0;
    global_count = 0;
    if (*(p+1) != '-') return -1;
    p += 2;
    global_count += 2;
    while (*p != ']') {
        if (*p == '[' || *p == '-' ||
            *p == '.' || *p == ',')
            return -1;
        res = continuous_count(p);
        if (*p == '>') offset += res;
        else if (*p == '<') offset -= res;
        else if (*p == '+') {
            index[_index] = offset;
            mult[_index] = res;
            _index++;
        }
        global_count += res;
        p += res;
   }
   if (offset != 0) return -1;
   return _index;
}
